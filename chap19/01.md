# NIO 소개

자바 4부터 새로운 입출력(NIO: New Input/Output)이라는 뜻에서 java.nio 패키지가 포함되었는데, 자바 7로 버전업하면서 자바 IO와 NIO 사이의 일관성 없는 클래스 설계를 바로 잡고, 비동기 채널 등의 네트워크 지원을 대폭 강화한 NIO.2 API가 추가되었다. NIO.2는 java.nio2 패키지로 제공되지 않고 기존 java.nio의 하위 패키지(java.nio.channels, java.nio.charset, java.nio.file)에 통합되어 있다. 이 책에서는 NIO와 NIO.2를 구별하지 않고 그냥 NIO로 부르기로 하겠다. 다음은 NIO에서 제공하는 패키지에 대해 간략히 설명한 표이다.

|NIO 패키지               |포함되어 있는 내용                                  |
|:------------------------|:---------------------------------------------------|
|`java.nio`               |다양한 버퍼 클래스                                  |
|`java.nio.channels`      |파일 채널, TCP 채널, UDP 채널 등의 클래스           |
|`java.nio.channels.spi`  |java.nio.channels 패키지를 위한 서비스 제공자 클래스| 
|`java.nio.charset`       |문자셋, 인코더, 디코더 API                          |
|`java.nio.charset.spi`   |java.nio.charset 패키지를 위한 서비스 제공자 클래스 |
|`java.nio.file`          |파일 및 파일 시스템에 접근하기 위한 클래스          |
|`java.nio.file.attribute`|파일 및 파일 시스템의 속성에 접근하기 위한 클래스   |
|`java.nio.file.spi`      |java.nio.file 패키지를 위한 서비스 제공자 클래스    |

## 1. IO와 NIO의 차이점

IO와 NIO는 데이터를 입출력한다는 목적은 동일하지만, 방식에 있어서 크게 차이가 난다. 아래 표는 IO와 NIO의 차이점을 정리한 것이다.

|구분                |IO                |NIO                           |
|:-------------------|:-----------------|:-----------------------------|
|입출력 방식         |스트림 방식       |채널 방식                     |
|버퍼 방식           |넌버퍼(non-buffer)|버퍼(buffer)                  |
|비동기 방식         |지원 안함         |지원                          |
|블로킹/넌블로킹 방식|블로킹 방식만 지원|블로킹/넌블로킹 방식 모두 지원|

### 스트림 vs. 채널

**IO**는 *스트림(Stream)* 기반이다. 스트림은 입력 스트림과 출력 스트림으로 구분되어 있기 때문에 데이터를 읽기 위해서는 입력 스트림을 생성해야 하고, 데이터를 출력하기 위해서는 출력 스트림을 생성해야 한다. 예를 들어 하나의 파일에서 데이터를 읽고 저장하는 작업을 모두 해야 한다면 `FileInputStream`과 `FileOutputStream`을 별도로 생성해야 한다.  
**NIO**는 *채널(Channel)* 기반이다. 채널은 스트림과 달리 양방향으로 입력과 출력이 가능하다. 그렇기 때문에 입력과 출력을 위한 별도의 채널을 만들 필요가 없다. 예를 들어 하나의 파일에서 데이터를 읽고 저장하는 작업을 모두 해야 한다면 `FileChannel` 하나만 생성하면 된다.

### 넌버퍼 vs. 버퍼

**IO**에서는 출력 스트림이 1바이트를 쓰면 입력 스트림이 1바이트를 읽는다. 이런 시스템은 대체로 느리다. 이것보다는 버퍼(Buffer: 메모리 저장소)를 사용해서 복수 개의 바이트를 한꺼번에 입력받고 출력하는 것이 빠른 성능을 낸다. 그래서 IO는 버퍼를 제공해주는 보조 스트림인 `BufferedInputStream`, `BufferedOutputStream`을 연결해서 사용하기도 한다.  
**NIO**는 기본적으로 버퍼를 사용해서 입출력을 하기 때문에 IO보다는 입출력 성능이 좋다. 채널은 버퍼에 저장된 데이터를 출력하고, 입력된 데이터를 버퍼에 저장한다.

![IO&NIO 구조]()

**IO**는 스트림에서 읽은 데이터를 즉시 처리한다. 그렇기 때문에 스트림으로부터 입력된 전체 데이터를 별도로 저장하지 않으면, 입력된 데이터의 위치를 이동해 가면서 자유롭게 이용할 수 없다.  
**NIO**는 읽은 데이터를 무조건 버퍼에 저장하기 때문에 버퍼 내에서 데이터의 위치를 이동해 가면서 필요 한 부분만 읽고 쓸 수 있다.

### 블로킹 vs. 넌블로킹

**IO**는 *블로킹(blocking)* 된다. 입력 스트림의 `read()` 메소드를 호출하면 데이터가 입력되기 전까지 스레드는 블로킹(대기 상태)된다. 마찬가지로 출력 스트림의 `write()` 메소드를 호출하면 데이터가 출력되기 전까지 스레드는 블로킹된다. IO 스레드가 블로킹되면 다른 일을 할 수 없고 블로킹을 빠져나오기 위해 인터럽트(interrupt)도 할 수 없다. 블로킹을 빠져나오는 유일한 방법은 스트림을 닫는 것이다.  
**NIO**는 블로킹과 넌블로킹(non-blocking) 특징을 모두 가지고 있다. IO 블로킹과의 차이점은 NIO 블로킹은 스레드를 인터럽트함으로써 빠져나올 수가 있다는 것이다. 블로킹의 반대 개념이 넌블로킹인데, 입출력 작업 시 스레드가 블로킹되지 않는 것을 말한다. NIO의 넌블로킹은 입출력 작업 준비가 완료된 채널만 선택해서 작업 스레드가 처리하기 때문에 작업 스레드가 블로킹되지 않는다. 여기서 작업 준비가 완료되었다는 뜻은 지금 바로 읽고 쓸 수 있는 상태를 말한다. NIO 넌블로킹의 핵심 객체는 멀티 플렉서(multiplexor)인 셀렉터(Selector)이다. 셀렉터는 복수 개의 채널 중에서 준비 완료된 채널을 선택하는 방법을 제공해준다.

## 2. IO와 NIO의 선택

네트워크 프로그램을 개발할 때 IO와 NIO 선택 기준에 대해 생각해보자. NIO는 불특정 다수의 클라이언트 연결 또는 멀티 파일들을 넌블로킹이나 비동기로 처리할 수 있기 때문에 과도한 스레드 생성을 피하고 스레드를 효과적으로 재사용한다는 점에서 큰 장점이 있다. 또한 운영체제의 버퍼 (다이렉트 버퍼)를 이용한 입출력이 가능하기 때문에 입출력 성능이 향상된다.

NIO는 연결 클라이언트 수가 많고, 하나의 입출력 처리 작업이 오래 걸리지 않는 경우에 사용하는 것이 좋다. 스레드에서 입출력 처리가 오래 걸린다면 대기하는 작업의 수가 늘어나기 때문에 제한된 스레드로 처리하는 것이 오히려 불리할 수 있다. 대용량 데이터를 처리할 경우에는 IO가 더 유리한데, NIO는 버퍼의 할당 크기도 문제가 되고, 모든 입출력 작업에 버퍼를 무조건 사용해야 하므로 받은 즉시 처리하는 IO보다는 좀 더 복잡하다. 연결 클라이언트 수가 적고, 전송되는 데이터가 대용량이면서 순차적으로 처리될 필요성이 있을 경우에는 IO로 서버를 구현하는 것이 좋다.